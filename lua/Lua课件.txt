	2.装饰器
	不修改函数本体，来修改函数功能
	--检测某个函数的性能
	user ="Boss"
	function test( ... )
		-- body
		for i = 1,10 do
			print(i)
		end
	end
	function Set_func( fun )
		-- body
		function CallFunc( ... )
			-- body
			if user =="Boss" then
				print("欢迎使用本系统")
			 fun();
		else
			print("权限不足")
		end
	end
	return CallFunc
	end
	test = Set_func(test);
	test();
	十八、lua中的面向对象
		Lua本身不是面向对象语言
		Lua用table来模拟面向对象

	--定义一个空表，相当于声明一个类
	person = {}
	person.name ="谭羽彬"
	person.Sex = "男"
	person.Age = "20"
	function person.Speak( ... )
		-- body
		print("请说话")
	end
	--相当于person.Speak = function()
	function person.Walking( ... )
		-- body
		print("在走路")
	end
	function person.ShowInfo( ... )
		-- body
		print("个人信息：")
		print("姓名："..person.name.."性别:"..person.Sex.."年龄："..person.Age)
		-- person.Speak()
		-- person.Walking()

	end
	--person.ShowInfo()
	a=person  --把person赋值给a
	person = nil
	a.ShowInfo()
	发现问题，需要改进
	如果定义一个局部的表来引用旧表，降低方法引用表字段的耦合
	this = person
	问题：通过将耦合嫁接到第三者并没有本质上解决问题
	缺乏封装性，存在缺陷
	lua中有self关键字，可以在方法中应用表自身方法
	--使用.来声明函数 self是一个参数，在调用时必须要传参
	function person.ShowInfo( self )
		-- body
		print("个人信息：")
		print("姓名："..self.name.."性别:"..self.Sex.."年龄："..self.Age)
		-- person.Speak()
		-- person.Walking()
	end
	--使用：来声明函数 self默认指向：调用函数的表
	function person:ShowInfo(  )
		-- body
		print("个人信息：")
		print("姓名："..self.name.."性别:"..self.Sex.."年龄："..self.Age)
		-- person.Speak()
		-- person.Walking()
	end

	--person.ShowInfo()
	a=person  --把person赋值给a
	person = nil
	a:ShowInfo(a)
	--无论是.还是：定义的函数，都可以通过.或者：来调用
	person.ShowInfo(person) --第一种用.调用要将table作为第一个参数传递
	person:ShowInfo() 		--第二种用：调用，不用传递self这个参数，self默认指向调用函数的表

	十九、模块
		1.模块的定义
		由变量、函数等组成的table，因此创建模块的本质就是创建一个table，在文件最后将该表返回
		2.模块的作用
			类似于一个封装库，把一些公共代码放在一个文件中，以API接口的形式在其他地方调用
			有利于代码的重用和解耦合
	二十、文件的相互调用
		使用lua内置函数 require（）来实现文件加载
		语法格式
		require（“文件名”）
		说明：
		1.执行require后，返回值：如果调用模块中有返回表 那么找到模块返回true，这个返回值就是返回调用文件中后最后返回表，如果没有返回表，没有找到就报错
		2.模块名称尽量与文件名相同
		注意：
		1.在文件中声明的local变量 作用域在文件内部，在函数中声明的local 变量 作用域在函数体内部
		2.如果被调用的lua文件，尽量定义为模块形式使用
		3.可以给加载的模块定义一个别名变量方便调用
	二十一、unpack函数（解包函数）
		接收一个表作为参数，并从下标1开始返回该表的所有元素(将表转为多重赋值的形式)
		tb = {1,2,3,4,5}
		a,b,c,d,e = unpack(tb)
		print(a,b,c,d,e)
		注意：
		1.unpack:可以容易将table集合中的数据解包输出
		2.与之对应的是table.concat(),将table中的数据拼接成一个字符串
		table.concat()将表中的元素拼接，最后以字符串的形式返回
		function testFun(str1,str2,str3 )
		-- body
		print(str3,str2,str1)
	end
	tb1 = {"sfasfa","时尚风格","148415"}
	testFun(tb1[1],tb[2],tb[3])
	testFun(unpack(tb1))
		可以将多个参数封装到一个表中，用unpack解包表然后传参
	二十二、字符串不变性原理
		字符串每一次连接之后，都会产生新的字符串
		这样不断连接字符串，就会不断产生大量新字符串，并且需要大量的复制操作
		随着连接操作不断增加，字符串越来越大，复制操作就会越来越耗时，执行速度会明显降低
		所有计算机语言都相同

		解决方法：使用table.concat去拼接
	二十三、表的本质
		表在lua中既不是值类型也不是变量而是对象
		1.lua中表不会暗中产生table的副本也不会产生新的表（与C#中基类和派生类作对比）
		2.一个持有表的变量与表自身之间没有固定关联性
		3.表是一种动态分配的对象，程序只保存他们的引用
		--正常输出持有表的变量与表自身之间没有固定关联性
		Array = {11,22,33,44,55}
		Array2 = Array
		Array = nil
		for k,v in pairs(Array2) do
			print(k,v)
		end
		--元素会改变
		Array = {11,22,33,44,55}
		Array2 = Array
		Array[2] = 88
		for k,v in pairs(Array2) do
			print(k,v)
		end
		说明：变量是指向了存有表的内存地址，如果变量为空，就打断了指向
		如果修改会修改指向内存地址的内容
	二十四、二维数组（矩阵）
	定义二维数组
	doubleArray={}
doubleArray[1] = {22,33,44,15}
doubleArray[2] = {66,77,55,11}
doubleArray[3] = {54,64,87,13}
--二维数组定义方式简化
doubleArray = {
	{22,33,44,15},
	{66,77,55,11},
	{54,64,87,13}
}
doubleArray = {}
--定义二维数组的初始化函数
function CreateDoubleArray( Row,Col )
	-- body
	for i=1,Row do
		doubleArray[i] ={}
		for j=1,Col do
			doubleArray[i][j] = 0
		end
	end
end
CreateDoubleArray(3,2)
--遍历二维数组
for i=1,#doubleArray do
	local lineShow = ""
	for j=1,#doubleArray[i] do
		lineShow = lineShow..doubleArray[i][j].."  "
	end
	print(lineShow)
end
--简化二维数组的迭代输出
	for k,v in pairs(doubleArray) do
		print(unpack(v))
	end
二十五、元表（Metatable）
	元表的作用与性质
	1.为什么需要元表
	在lua中每个值都有一套预定义的操作集合，例如可以将数字相加，连接字符串
	问题：无法将两个table相加，无法对两个函数做比较，也无法调用一个字符串
	2.元表的作用
	lua中提供了元表方法来修改一个表的行为，使得表在面对一个非预定义的操作时
	执行指定操作
	--定义“原始表”
tab1 = {10,20,30}
tab2 = {20,30,40}
--直接相加会报错
--tabRes = tab2+tab1
--1.定义元表(空表)
setTable = {}
--2.定义元素的加法函数
--函数名是特定的，函数名代表函数行为
--参数传入两个表，第一个表是加号左边的元素，第二个表是加号右边的表
function setTable.__add(tab1,tab2)
	-- body
			local AddTableRes = {}
	for k,v in pairs(tab1) do
	if v ==nil then
		break
	end
	AddTableRes[k] = tab1[k] + tab2[k]
end
return AddTableRes
end
--3设置元表
--哪个表可以有元表的行为，就给哪个表设置对应元素
setmetatable(tab1,setTable)
setmetatable(tab2,setTable)
--4.测试表的相加
tabRes = tab2+tab1
print(unpack(tabRes))
	当lua试图将两个表相加时
	1.检查相加的两个表是否有设置元表
	2.检查这两个相加的表的元表是否有“_add”函数
	3.如果有，就调用对应函数，将相加的表作为参数进行传递
	注意：函数名"__add"是固定的，这样在元表中定义的固定含义的函数叫做“元方法”

	关于元表的两个重要函数
	setmetatable(t1,t2)		将t2设置为t1的元素(t2,t1都是表)
	getmetatable(t)			获取到t的元素，并返回
	元表的性质：
	1.任何table都可以作为任何table的元素（不一定要元方法）
	2.一组相关的table可以共享一个通用的元表，此元表描述了他们共同的行为
	3.一个table可以是自己的元表


	运算符相关"元方法"

	算术类
	__add	+
	__sub	-相减
	__mul 	*
	__div	/
	__mod	%
	__unm	-取反
	__concat	..字符串连接

	关系运算符
	__eq		==
	__lt		<
	__le		<=

	库定义元方法
	__tostring	当print(表)的时候 调用该元方法
	tab1 = {
		year =2019,
		month = 9,
		day = 2
	}
	local setTable = {}
	function setTable.__tostring( table )
		-- body
		local Result = string.format("%s - %s - %s ",table.year,table.month,table.day)
		return Result
	end
	setmetatable(tab1,setTable)
	print(tab1)

	--元素可以被随意设置，不安全
	__metatable 	当给一个元表设置了这个元方法，则设置了这个元表的表，无法修改他的元表

	setTable.__metatable = "无法访问"
	setmetatable(tab1,setTable)
	print(tab1)
	--setmetatable(tab1,{})
	print(getmetatable(tab1))

	设置过__metatable后的表不能通过getmetatable来获取元表

	表访问的元方法
	__index	当访问表中不存在的字段时，得到结果为nil
	如果给这个表设置了带有__index元方法的元表，
	当lua访问表中元素结果为nil时
	会去找__index提供的返回值

	2.__newindex
	当对一个table中不存在的键赋值时，
	lua解释器会寻找这个表的元表中的__newindex方法，
	如果有这个方法，解释器就会调用
	不会进行赋值

	注意：对已有的键赋值不起作用

	用途：对表进行保护
		tab = {str1 = "sdsdsds"}
	tab.str2 = "Tam"
	setTable = {}
	function setTable.__newindex( self,k,v )
		-- body
		print("检测到给当前表添加数据K= "..k.." v= "..v)
	end
	setmetatable(tab,setTable)
		tab.str3 = "yu"
	3.rawset函数
	当_newindex被执行，在函数体内部定义的rawset会对表进行赋值
	此时增加的记录会生效
	4.简化元表的设置
	由于setmetatable()返回了设置好元表的表(返回了传入的第一个参数的表)
	利用这个特点简化写法

		tab1 = setmetatable
		({str1 = "Tam"},
		{__newindex = function (self,k,v )
			-- body
			rawset(self,k,v)
			print("检测到给当前表添加数据K= "..k.." v= "..v)
		end
		})
		tab1.str3 = "yu"
		print(tab1.str3)
	5.__call(调用表原方法)
	只要将一个表设置了包含有__call元方法的元表，那么这个表可以作为函数来调用
	调用时会执行__call元方法
	用于模拟构造函数
	mytable = setmetatable(
	{},
	{
	__call = function ( self )
		-- body
		print("call元方法被调用",self)
	end
	}
	)
mytable()
	注意：元表中的元方法指向的是设置元表的表

二十六、面向对象编程深化
	1.基本对象模拟
	person = {}
	person.name = "TAM"
	person.Sex = "男"
	function person:PersonInfo( ... )
	-- body
	print(string.format("人员名字 %s 性别 %s",self.name,self.Sex))
	end
	print(person.name)
	person:PersonInfo()
	2.利用__index实现创建对象机制

	第一种实现方式
	--类 通过类去创建对象
	local person = {}
	--创建对象的方法
	function person:New(Name,Sex )
		-- body
		o=setmetatable({},self)
		self.__index = self
		o.Name = Name
		o.Sex = Sex
		return o
	end
	function person:personInfo( )
		-- body
		print(string.format("人员名字 %s 性别 %s",self.Name,self.Sex))
	end
	local Tam = person:New("TAM","男")
	local yu = person:New("yu","女")
	print(Tam)
	print(yu)
	Tam:personInfo()
	yu:personInfo()
	
	第二种实现方式
		--方法2
	local person1 = setmetatable(
		{personInfo1 = function (self )
			-- body
			print(string.format("人员名字 %s 性别 %s",self.Name1,self.Sex1))
		end
		},
		{
			__call = function (self,Name1,Sex1)
				-- body
				local tb = {}
				tb.Name1 = Name1
				tb.Sex1 = Sex1
				setmetatable(tb,{__index=self})
				return tb
			end
		}
		)
		local Tam = person1("TAM","男")
	local yu = person1("yu","女")
	print(Tam)
	print(yu)
	Tam:personInfo1()
	yu:personInfo1()

	3.利用__index实现继承

	local father = {}
	father.Name2 = "TAM"
	father.Age = 30
	function father:personInfo2( ... )
	-- body
		print(string.format("人员名字 %s 年龄 %s",self.Name2,self.Age))
	end
	--定义子类
	local Son = {}
	Son.Name2 = "yu"
	Son.Age = 10
	function Son:Speak()
	print(self.Name2.."在说话")
	end
	--子类中使用子类中的成员变量，如果访问子类中不存在的变量，则去父类中查找
	setmetatable(Son,{__index=father})
	print(Son.Name2)
	Son:personInfo2()
	Son:Speak()